# やったこと
- Face Destinyのログイン処理(フロントとバックエンドの繋ぎ合わせを新規登録、ログインを終わらせた)
- AWS (VPCの復習とEC2について新たに勉強した)
- アーキテクチャ(本読んだ)：第三章

# 何につまづいたのか・分からなかったこと
- EC2とは何か
- アーキテクチャの構造化プログラミングって何？
- interfaceが依存性を逆転させることはわかったが、逆転って具体的にどういう状態なのかがイメージつかなかった。

# 理解したことを踏まえて説明する

## AWS
物理サーバー上にいくつもの仮想サーバーが動いている。
仮想サーバーは

- OS
- CPU
- メモリ
- ストレージ
- NIC

の5つを持って、動いている。

AWSでは以下のように置き換わっている。
- 仮想サーバー → EC2
- OS → AMI
- CPU,メモリ → インスタンスタイプ
- ストレージ → EBS
- NIC → ENI

# AMI
OSやソフトウェアや設定を含む「イメージ」
イメージ：仮想サーバーをバックした際にできる更新されたファイルのこと。
イメージ：ある時点のサーバーの中身を丸ごと冷凍保存した、金型(テンプレート)のこと。

- なぜイメージと呼ばれているのか
物理的なハードウェアではなく、その中に入っている「データや設定の状態」をパシャリと取って、ファイルに書き出したもの。だからイメージと呼ばれる。

イメージは、以下の3つが1つのパッケージとして固められている

- OS (心臓部)：LinuxやWindowsなどのシステムそのもの。
- ソフトウェア(道具)：Webサーバー（Nginx）、言語（Go, Python）、データベースなど。
- 設定：ネットワーク設定、ユーザー権限、環境変数など。

## 質問：私たちエンジニアはいつもソフトウェアの中身を作っていたってことになるんですか？
このOSって私たちが特に意識せずとも勝手にあるって感じなんですか？
OSがあまり想像つかなかった。

## ans
OSは最初から用意されている土台であり、その上で「ソフトウェアを動かすためのコード」を私たちが書いているということになる。
私たちが普段「プログラムを書いて動かす」と言っている時、実はOSという巨大なシステムの上で動く、システムを作っているということ。あの黒い画面にコマンドを打っているが、あれが、OSってやつ。

## 質問：元々は、自分のパソコン上のOSでしか動かなかったものを世のネットワークに公開するための仮想サーバーを立てるということでEC2を使うってこと？

## ans
まさに「自分の手元（ローカル環境）」という小さな世界から、「インターネット（パブリックな世界）」という大海原へ、あなたの作ったアプリケーションを引っ越しさせるのがEC2の役割。



## アーキテクチャ
構造化プログラミングは、順次、分岐、繰り返しの3つの基本構造のみを用いてプログラムを記述する手法のこと。元は「goto文」が使われていたみたいだけど、これだと処理の流れがぐちゃぐちゃで追いにくいことがあった。なので、順次、分岐、繰り返しの3つだけに絞ることによって、コードを上から下に読み進めることができ、プログラムの論理構造が追いやすくなった。これは3つのパラダイムが制約を課しているが、どちらかと言うと、できることではなく何をすべきではないかを重視している。

3つのパラダイムが課している規律
1. 構造化プログラミング：goto文の禁止
2. オブジェクト指向プログラミングのinterfaceの活用：依存関係の逆転
3. 関数型プログラミング：代入の禁止

2について、
一般的な設計思想では、上位・下位をこう定義する。

- 上位：ドメインルールのこと
    - システムが何をするかという本質的なルール。
    - 例：銀行システムで、残高以上に引き出せない

- 下位：詳細(外部技術、メカニズム)のこと。
    - そのドメインルールをどうやって実現するかという具体的な手段のこと。
    - MySQL,JSON,HTTP,AWSとか

ビジネスルールは、データベースが何であっても変わらないはず。だから、ビジネスルールの方が偉い(上位)と考える。
今までは、上位が下位を知る、実装を合わせることでやりくりをしていた。
interfaceという手段の登場によって、上位側がルールを策定し、強気に出れるようになった。今まで何もしなくてよくなった。下位がそのinterfaceから上位を満たすようにならないといけなくなったというイメージ。

これをusecaseとrepositoryを例にすると、ロジックとDBとのやり取りで、
通常だと、依存も実行も usecase → repositoryとなっている。usecaseという上位がrepositoryという下位に合わせないといけなかった。さらに、一つの技術に特化し、合わせているので、当然融通も効かない。
これに対し、interfaceを使うと、実行はそのままだが、依存関係が、usecase ← repositoryになって、DB側が上位のinterfaceの制約を満たさないといけないようにした。さらにinterfaceのポリモーフィズムによって、どんな人(技術か)は気にせずにただどういうことをするかのみを知れば良いので、MySQL,Postgreによる切り替え、柔軟性が出てきた。



# 感想
この上位、下位は変わりにくさで決まるってことなんか？interfaceについて抽象化とポリモーフィズムがごっちゃになっていたからいい整理になった。どっちかというとinterfaceが「抽象化」と「ポリモーフィズム」の2つの役割を持っているってことなのかな？

OS上で動いているものがソフトウェアってことなん？