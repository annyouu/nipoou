# やったこと
- Dockerの理解
- Dockerfile,Dockercompose.ymlってそれぞれなんなのかを理解する
- Goアプリ、PostgreSQL、Redisをそれぞれコンテナ化し、管理するDocker下に移行した。

# 最初の状態
Dockerとかの技術は知っていたが、なんのために使うのかがよくわからないかった。

# 何につまづいたのか・分からなかったのか
Dockerがコンテナを作って、どのPCで同じように動作することは知っていたが、Linuxとの兼ね合いは？そもそもなぜDockerが生まれたのかが詰めていなかった。

# なぜ詰まったのか
Dockerについて学ぶ機会がなかった。
いつも、ローカルでの開発は、Dockerとか使わずにやっていて、技術を調べることをしていなかったため、急に使うとなるとわからないことだらけになった。

# どう理解に持っていったのか
まず従来のアプリケーション開発における問題点を確認し、そこから仮想化技術が生まれた背景を理解した。仮想化技術によって、アプリケーション間の競合や依存関係の問題は解消された一方で、仮想マシンごとにゲストOSを含むOS全体を起動する必要があり、その分リソース消費が大きく、動作が重くなるという新たな課題があることが分かった。
その後、ホストOSのカーネルを共有しながら、プロセス単位でアプリケーションとその依存関係を隔離するコンテナ技術が登場したことを理解した。これにより、OSを丸ごと起動することなく実行環境を分離でき、仮想化技術における動作の重さという問題が解消されていることを知った。

※ カーネル： (kernel)は「核」という意味で、OSの中でも「ハードウェアに直接命令を下す」OSの心臓部。

# 今ならどう説明するか
コンテナはゲストOS自体を動かしていない。ホストOSのカーネル上で、アプリケーションのプロセスをコンテナで、隔離して動かしている。

### 仮想マシン (VM)
```
ハードウェア
  └ ホストOS
      └ ハイパーバイザ
          └ ゲストOS（カーネルあり）
              └ アプリ
```
ゲストOSを含めたホストOSを丸ごと起動する。
動作が重い。→ ゲストOSごとにカーネルを起動しているから。
- ホストOSのカーネルは1つ
- ゲストOSのカーネルは、仮想環境(VM)ごとに1つずつある。

### コンテナ (Docker)
```
ハードウェア
  └ ホストOS（カーネル1つ）
      └ Docker
          └ コンテナ
              └ アプリ（＋ライブラリ）
```
コンテナでは、ゲストOSは存在しない。カーネルはホストOSの1つだけ。
ホストOSのカーネル上に、プロセス単位で隔離された実行環境を作る。
1つのホストOSカーネルの上で、namespace と cgroups によって
複数の独立したプロセス空間（コンテナ）が動いている。
コンテナには、アプリケーションとミドルウェアが入っている。
